# Abyss_clider_card_game

## Здесь вы видете основной экран проекта: ![image](https://user-images.githubusercontent.com/127990023/226963080-43a34d59-546e-44c9-be1a-b0681fc72552.png)

# Ветвления
### Для понимания ветвления веток в проекте, стоит можно просмотреть инструкцию: Основное предназначение Git – это сохранение снимков последовательно улучшающихся состояний вашего проекта.

Здесь перечислены только обязательные и полезные (на мой взгляд) параметры, ибо перечисление всех неуместно.Для этого используйте git command -help или --help, где command — название команды справку о который вы хотите получить.

## Главные ветви
![image](https://user-images.githubusercontent.com/127990023/228050292-02329308-e1ef-476a-ae3f-2e7f6fb0514a.png)

Центральный репозиторий Main содержит три главные ветки, существующие всё время:
### * Mobile app
### * Web app
### * Server
### Main – директория с описаниями, документами и ссылками на другие ветки. Само приложение туда напрямую не грузится.
### Mobile App – Мобильное приложение
### Web App – Веб-версия разработки
### Server – Серверная часть

## Вспомогательные ветви

Кроме главных ветвей Mobile App, Web App и Server наша модель разработки содержит некоторое количество типов вспомогательных ветвей, которые используются для распараллеливания разработки между членами команды.

Мы используем следующие типы ветвей:
![image](https://user-images.githubusercontent.com/127990023/228050349-01f8db1a-34e1-43a3-ab84-38d983d8bfbf.png)


У каждого типа ветвей есть своё специфическое назначение и строгий набор правил, от каких ветвей они могут порождаться, и в какие должны вливаться. На картинке показано, кто и от кого зависит:
![image](https://user-images.githubusercontent.com/127990023/228050386-a52b7238-dfad-4ed3-a0c1-575f58d58b96.png)


Конечно же, с технической точки зрения, у этих ветвей нет ничего «специфического». Разбиение ветвей на категории существует только с точки зрения того, как они используются. А во всём остальном это старые добрые ветви Git.

## Пример создание ветви функциональности (Feature)
При начале работы над новой функциональностью делается ответвление от ветви разработки (develop).
## Пример:
### $ git checkout -b 1.0.1f 1.0.1
### Switched to a new branch "1.0.1f"

## Добавление завершённой функциональности в develop
Завершённая функциональность (Feature) вливается обратно в ветвь разработки (develop) и попадает в следующий релиз.
## Пример:
### $ git checkout 1.0.1
### Switched to branch '1.0.1'
### $ git branch 1.0.2
### Switched to a new branch "1.0.2"
### $ git merge 1.0.1f

## Состояние файлов
Для просмотра состояния файлов в репозитории используйте:

## git status [<опции>]

Эта команда может показать вам: на какой ветке вы сейчас находитесь и состояние всех файлов. Обязательных опций нет, из полезных можно выделить разве что -s которая покажет краткое представление о состояний файлов.

## Жизненный цикл файлов
Этот цикл можно представить следующим образом:
Unmodified -> Modified -> Staged -> Unmodified
То есть вы изменяете файл сохраняете его в индексе и делаете коммит и потом все сначала.

## Работа с индексом
Индекс — промежуточное место между вашим прошлым коммитом и следующим. Вы можете добавлять или удалять файлы из индекса. Когда вы делаете коммит в него попадают данные из индекса, а не из рабочей области.

## Что бы просмотреть индекс, используйте git status.

## Что бы добавить файлы в индекс используйте
### git add [<опции>]

## Полезные параметры команды git add:

### -f, --force — добавить также игнорируемые файлы
### -u, --update — обновить отслеживаемые файлы

## Работа с коммитами
## Для того что бы сделать коммит ваших изменений используйте:

### git commit [<опции>]

## Полезные опции команды git commit:

### -F, --file [file] — Записать сообщение коммита из указанного файла
### --author [author] — Подменить автора коммита
### --date [date] — Подменить дату коммита
### -m, --mesage [message] — Сообщение коммита
### -a, --all — Закоммитеть все изменения в файлах
### -i, --include [files...] — Добавить в индекс указанные файлы для следующего коммита
### -o, --only [files...] — Закоммитеть только указанные файлы
### --amend — Перезаписать предыдущий коммит
## Вы также можете изменить, удалить, объединить любой коммит.

## Просмотр истории
#### С помощью команды

#### git log [<опции>] [<диапазон-редакций>]

#### вы можете просматривать историю коммитов вашего репозитория. Есть также куча параметров для сортировки и поиска определённого коммита.

### Полезные параметры команды git log:

#### -p — Показывает разницу для каждого коммита.
#### --stat — Показывает статистику измененных файлов для каждого коммита.
#### --graph — Отображает ASCII граф с ветвлениями и историей слияний.

## Ветка расположения приложения: https://github.com/SWATOchek/Abyss_clider_card_game/tree/mobile_app
## Ветка расположения сервера: https://github.com/SWATOchek/Abyss_clider_card_game/tree/mobile_server
## Ветка веб части приложения: https://github.com/SWATOchek/Abyss_clider_card_game/tree/web_app
## Главная ветка: https://github.com/SWATOchek/Abyss_clider_card_game/tree/main
## Документация: https://github.com/SWATOchek/Abyss_clider_card_game/tree/main/documentations

# Общее
## В readme.md вы можете прочесть инструкцию и путеводитель по ПО в гитхабе

## В папке с сервером находятся файлы, который нужны для того, чтобы подключаться к нему (серверу) и приложение могло работаь онлайн ![image](https://user-images.githubusercontent.com/127990023/226740843-03088f46-ec73-4b99-b4eb-7b82b81574ab.png)

## В папке с приложением есть подпаки, где хранятся файлы с музыкой, картинками и отдельно, ещё один ![image](https://user-images.githubusercontent.com/127990023/226741605-0aca8332-c6cf-4e42-ba84-27077ae0b4a4.png)

## В папке с документами есть файл с отчётами по каждому человеку, а также документация и презентация проекта: ![image](https://user-images.githubusercontent.com/127990023/226742324-ec30c788-af2a-407c-9f59-cfbd251754b3.png)

# Работа с докером 

Основное предназначение Docker - заключается в создании и развертывании приложений в среде, изолированной от других приложений. Docker-контейнеры являются удобным средством, с помощью которого разработчики могут «укладывать» свои проекты, уменьшая эффект «луж». Docker-контейнеры – это «малые», «легкие» контейнеры, которым нужно минимум ресурсов.

## Создание серверного приложения 

1. Создание папки, в которой будет складываться Dockerfile.
2. Создание Dockerfile со следующими командами:
```
FROM ubuntu:16.04 - импорт образа 
RUN apt-get update && apt-get install -y \
python3 \
python3-pip \
nginx \ 
supervisor \
pip3 install uwsgi flask - Установка необходимых пакетов и зависимостей в контейнер
EXPOSE 80 443 - открытие HTTP/HTTPS портов 
COPY ./ /app/ - копирование проекта в контейнер 
WORKDIR /app/ - создание рабочего пути
RUN chmod +x start.sh - меняем права на файл
CMD ["./start.sh"]  - запуск серверного приложения 
``` 

3. Настройка start.sh, который будет запускать uWSGI, Nginx, Flask: 

```#!/bin/bash 

# Start the first process 

nginx 

# Start the second process 

uwsgi --ini /app/uwsgi.ini & 

# Start the third process 

python3 /app/main.py & 

# Naive check runs checks once a minute to see if either of the processes exited. 

while sleep 60; do 

ps aux |grep nginx |grep -q -v grep 

PROCESS_1_STATUS=$? 

ps aux |grep uwsgi |grep -q -v grep 

PROCESS_2_STATUS=$? 

ps aux |grep main.py |grep -q -v grep 

PROCESS_3_STATUS=$? 

# If the greps above find anything, they exit with 0 status # If they are not both 0, then something is wrong if [ $PROCESS_1_STATUS -ne 0 -o $PROCESS_2_STATUS -ne 0 -o $PROCESS_3_STATUS -ne 0 ]; then echo "One of the processes has already exited." exit 1 fi done ```

4. Выполнить docker build, указав имя image: docker build -t server_image 

5. Запустить Docker-контейнер:
```docker run -d -p <host_port>:<container_port>  server_image```

6. Проверить, что контейнер успешно запущен:
```docker ps```

7. Установить нужные для работы приложения связки (bindings):
```docker exec -it  server  <command>```,
где `<command>` — команды, нужные для установки bindings.
``` 

## Создание веб приложения 

1. Создание Dockerfile со следующим содержимым:

FROM ubuntu:18.04

# Установка необходимых пакетов и зависимостей
RUN apt-get update && apt-get -y install \
wget \
curl \
git \ 
build-essential \ 
gcc \ 
make \ 
libssl-dev \ 
libffi-dev \ 
python3.6 \ 
python3-pip &&\ 

## Установка приложения 

WORKDIR /usr/src/app

COPY . .

RUN pip3 install --no-cache-dir -r requirements.txt

EXPOSE 8080
## Запуск приложения 
CMD ["python3", "app.py"] 
``` 

2. Выполнить docker build, указав имя image: `docker build -t image_app .`

3. Запустить container c image: `docker run -d -p 8080:8080 image_app`
